# Leetcode 209.长度最小的子数组

> [!TIP]
>
> - 本题关键在于理解滑动窗口：两个指针都只向一个方向（后）滑动，而不是来回滑；

Leetcode 题目跳转： [209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

Leetcode 题解跳转：[lc[209].长度最小的子数组｜1.暴力解法 2.双指针滑动窗口](https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/2756295/lc209chang-du-zui-xiao-de-zi-shu-zu-1bao-2bvn)

<img src="https://cdn.jsdelivr.net/gh/boyan-uni/pic-bed/img/lc209.png" alt="image-20240426002823991" style="width:60%;" />

## 题解

### 解法1：暴力解法

#### 解题思路

直接遍历搜索，双层for循环嵌套；

#### 复杂度

- 时间复杂度：O(n^2)；
- 空间复杂度: O(1)，原地算法；

### 解法2：双指针（滑动窗口）

#### 解题思路

- 读题重点：

  - 输入: n个**正**整数的数组, int target；

  - 核心：找总和 **>= target**的**长度最小的子数组**；

  - 输出: 子数组的**长度**, 不需要记录子数组内容；
    - 如果需要, 增加两个辅助变量记录子数组起始下标位置, 持续更新；

- 图解：

  <img src="https://cdn.jsdelivr.net/gh/boyan-uni/pic-bed/img/lc209-%E5%8F%8C%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%9B%BE%E8%A7%A3.png" alt="image-20240426005934550" style="width:80%;" />

  - 结合代码和注释更好理解；

#### 复杂度

- 时间复杂度：O(2n) = O(n)，在一次中，两个指针分别遍历了一次全部数据元素；
- 空间复杂度：O(1)，原地算法；



## Code

### 双指针（滑动窗口）

```java
// 双指针，滑动窗口：两个指针都只向一个方向（后）滑动，而不是来回滑
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 初始化辅助变量
        int result = Integer.MAX_VALUE;
        int sum = 0;
        // 初始化指针
        int start = 0, end = 0;
        // 开始滑动窗口
        for (; end < nums.length; end++) {
            sum = sum + nums[end];
            // 每后移end一次，需要判断start-end之间的子数组是否符合要求
            // if / while, why???????：因为一旦sum符合要求，前面的start指针就要开始不断后移，尝试尽可能缩短子数组长度
            while (sum >= target) {
                // 检查是否更新result（最小子数组长度）、先更新sum值、再后移start
                result = Math.min(result,(end - start + 1));
                sum -= nums[start++];
            }
        }
        // 返回结果（如果不存在符合条件的子数组，返回 0）
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
// 时间复杂度：O(2n) = O(n)，在一次中，两个指针分别遍历了一次全部数据元素；
// 空间复杂度：O(1)，原地算法；
```



























































